\chapter{User Interface}

\section{Basic concepts}

The central element of the user interface is the node graph editor. Inside it
you create and link nodes of different type to assemble the scene containing all
the computed objects.

There are several different kind of nodes, each with a different functionality
and a different number of inputs, but only one output. This output contains
some data that can be used as an input to one or more other nodes, simply by dragging a link
between them using the mouse. While the same output can be used as input to multiple nodes,
the opposite is an error: you cannot feed data coming from 2 outputs into one input.

One can only connect an output to an input of the same type. For example, it
would not make sense to pass an \textbf{Interval} to a node that requires
a \textbf{Matrix} input. See the next section for a complete description of
all datatypes.

\section{Data types}

\subsection{Geometry}
The most important data type is \textbf{Geometry}. This represents a generic geometric
object, it might be a point (0D), a curve (1D), a surface (2D) or a pre-fabricated mesh.
Most of the time we start by creating a geometry of some sort, then
manipulate it with transform functions, and in the end plug the result
into a Renderer node that is the one that turns our data into something
that we visualize on screen.
As we will see later on, parametric transformations and sampling operations
can change the geometric dimension of a Geometry object. As an example,
a given curve can become a surface by applying a parametric transform to it.

\subsection{Vector}
As the name implies, the data contained in this type is just a vector with
user-chosen $x$, $y$ and $z$ coordinates. There is however a very important
difference between a vector and a point: a vector is \textbf{not} a Geometry and
can \textbf{only} be used to build a translation Matrix, as a plane normal or for
visualization purposes. This is because the vector is to be intended as a direction,
not as a generic coordinate in the 3D space. If we write a vector
in homogeneous coordinates, its $w$ component is \textbf{always zero}.

\subsection{Matrix}
This data contains a 4x4 matrix which should be interpreted as a transformation written in
homogeneous coordinates. The matrix can be either parametric or a constant-valued one.
See the nodes section of this chapter to know more about the different matrices that can
be created.

\subsection{Time Transform}
This is a very specific 4x4 matrix with an implicit parameter named $t$ as in \textit{time}.
By writing out time-dependent expressions, the user can attach some animation to 
a rendered Geometry object. This can be useful for example to show the movement of a
point along a curve, or to display how a transformation progressively deforms an object
into a final shape.

\subsection{Interval and Value}
Both \textbf{Interval} and \textbf{Value} data deals with parameters: the first contains
the parameter and its interval boundaries, while the second contains the parameter and
a specific value in its interval, to be used in a \textbf{Sample parameter} node.

\section{Nodes}

Each node represents an operation that creates or modifies data. Besides the inputs and
the output, many nodes also have internal fields in which the user can write an expression
or choose a value for a given property (e.g. a function or ``$pi/4$'' for an angle).

To add a node, simply right-click on empty space inside the node graph editor;
a popup menu will open to display all the available node types, grouped by categories.
Clicking on a menu item will place the newly-created node of the corresponding type.
The following section contains a detailed explaination of all menu entries.

\subsection{Geometry submenu}
The geometry submenu contains the following nodes:

\subsubsection{Curve}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Interval              \\
    \hline
    Fields: & fx, fy, fz            \\
    \hline
    Output: & a 1D Geometry object  \\
    \hline
\end{tabular}
\vspace{5pt}

This node is used to create a parametric curve using a parameter as defined in
Interval and with the given expressions for fx, fy and fz. Simple to use,
just make sure to create an expression using the correct parameter name
(i.e. the same name used inside the Interval given as input)

\subsubsection{Bezier}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & 2, 3 or 4 Points (0D Geometry objects)\\
    \hline
    Fields: & Quality\\
    \hline
    Output: & a 1D Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

This node uses its inputs as control points for a Bezi\`er curve. The degree of the
curve depends on how many inputs have been connected. Empty inputs are ignored.
The Quality field determines how many points will be used to approximate the ideal
Bezi\`er.

\subsubsection{Surface}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & 2 Intervals\\
    \hline
    Fields: & fx, fy, fz\\
    \hline
    Output: & a 2D Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

Similarly to the curve node, this can be used to create a parametric surface
given two intervals and the given expressions for fx, fy and fz.
Both intervals are required, and the user should make sure to use both of them,
since if one is ignored it is likely that nothing will be visualized as a result,
since that will create a degenerated surface.

\subsubsection{Plane}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & one point (0D Geometry), one Vector\\
    \hline
    Fields: & none\\
    \hline
    Output: & a Mesh Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

This node takes one point and a normal vector to create a special representation
of a plane. In particular, the representation consists of an evely-spaced grid centered
about the point given as input.

Please note the output is \textbf{not} a 2D Geometry, but a Mesh Geometry,
which means that the purpose of this node is to have something useful for
visualization purposes, not to have a built-in parametric surface.
It is not allowed to apply a parametric transform to a Mesh Geometry,
only a constant-valued transform or a time-dependant transform can be applied to it.

\subsubsection{Primitive}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & Kind (a drop-down menu), Size\\
    \hline
    Output: &  a Mesh Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

This node allows the user to create a basic primitive of the given kind
(Cube, Sphere, Cylinder, Cone, Pyramid or a Dice). The Size fields allows
adjusting the primitive dimensions. See the question mark next to the 
slider for a description of how this value effects the output.

Just like the Plane node, the output is a Mesh Geometry, which is useful
for quick visualization or similar purposes. Again, only constant-valued
or time-dependent transforms can be applied to this object,
parametric transforms are not allowed.

\subsection{Parameters submenu}
This submenu contains all the nodes related to parameters

\subsubsection{Interval}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & Name, Begin, End, Quality\\
    \hline
    Output: &  Interval\\
    \hline
\end{tabular}
\vspace{5pt}

This node defines a parameter. By assigning a name, you will then be able
to use this parameter in expressions for parametric curves, surfaces and matrices.
Begin and End define the closed range in which the parameter lives, while quality
allows the user to choose how many discretization points will be used when creating
a curve or a surface out of this parameter.

\subsubsection{Value}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & Name, Value\\
    \hline
    Output: &  Parameter Value\\
    \hline
\end{tabular}
\vspace{5pt}

In a similar way to the Interval node, the Value node lets you define a parameter
and assign a specific value to it. You can use it either as a "variable"
to be used as input for a matrix (e.g. define a theta and then use theta as the
angle for a rotation matrix expressions) or as an input to the Sample Parameter node.

\subsubsection{Sample Parameter}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & 1D or 2D Geometry object, Parameter Value\\
    \hline
    Fields: & none\\
    \hline
    Output: &  0D or 1D Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

The parameter sampling operation allows you to "downgrade" the dimension of a parametric
Geometric object, by fixing the value of a parameter to the value given as input.

In order for the operation to succeed, the Geometry must have a parameter with the same name
as to the one used in the Value input (e.g. if a surface is $S(p, q)$, your value cannot
have the parameter name $r$, only $p$ or $q$ will be accepted). Please note that 1D Geometry created with the Bezi\`er
curve uses a hidden parameter name, and cannot therefore be sampled.

\subsection{Transformations submenu}
This submenu contains all nodes used to define transformation matrices and to
apply those to geometry objects.

\subsubsection{Generic Matrix}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Parameter (either Interval or Value), facultative\\
    \hline
    Fields: & matrix elements\\
    \hline
    Output: &  Matrix object\\
    \hline
\end{tabular}
\vspace{5pt}

This node is used to define a generic Matrix, by writing one expression for each
matrix element. If an Interval is given as an input, then the output matrix will be
a parametric one.
Note that due to the nature of the software, there is no way to define a projection matrix,
since the last row of the matrix is fixed and cannot be modified.

As usual, if you provide a parameter as an input, make sure you
will be actually using it inside the expressions to prevent any kind of visualization
issue.

\subsubsection{Rotation Matrix}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & Axis (drop down menu), Angle\\
    \hline
    Output: &  Matrix object\\
    \hline
\end{tabular}
\vspace{5pt}

This node allows the user to quickly define a matrix which represents a rotation
of Angle radians around the chosen Axis.

\subsubsection{Translation Matrix}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Vector\\
    \hline
    Fields: & none\\
    \hline
    Output: &  Matrix Object\\
    \hline
\end{tabular}
\vspace{5pt}

Similarly to the previous, this node allows the user to quickly define a translation
matrix given the input Vector

\subsubsection{Transform}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Geometry object, Matrix object\\
    \hline
    Fields: & none\\
    \hline
    Output: &  Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

This node takes a matrix and applies it to a geometry, returning the transformed geometry.
If the input matrix was a parametric matrix, then a parametric transformation will be applied.
Please note that a parametric transform is not ``blindly'' applied to an object: if we have
a parametric curve or surface that depends on the same parameter used by the matrix,
the output geometry will still be a curve or a surface, modified accordingly
(e.g. applying a translation to a circle may output a spiral)

\subsubsection{Time Transform}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & matrix elements\\
    \hline
    Output: &  Time Transform object\\
    \hline
\end{tabular}
\vspace{5pt}

This node creates a Time Transform object, read th paragraph in the Data Types
section for more informations. All the expressions for the matrix elements
can contain the parameter $t$, i.e. ``time''.

\subsection{Point}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & $x$, $y$, $z$\\
    \hline
    Output: &  0D Geometry object\\
    \hline
\end{tabular}
\vspace{5pt}

A very simple node to create a point. The implicit $w$ coordinate is set to $1$

\subsection{Vector}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & none\\
    \hline
    Fields: & $x$, $y$, $z$\\
    \hline
    Output: &  Vector object\\
    \hline
\end{tabular}
\vspace{5pt}

A very simple node to create a Vector. As described in the data types section, a vector
is to be interpreted as a ``direction'', and the implicit $w$ coordinate is set to $0$

\subsection{Geometry Renderer}


\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Geometry, Time Transform\\
    \hline
    Fields: & Thickness, Color\\
    \hline
    Output: &  none\\
    \hline
\end{tabular}
\vspace{5pt}

This node is the one responsible for taking a Geometry object and rendering it to the screen.
Every frame the the Time Transform is applied to the it before rendering, by evaluating the
transform with a different value of $t$. The user can choose what color to use for any kind
of Geometry, while the Thickness value only effects the display of 1D geometries (curves).

\subsection{Vector Renderer}

\hspace{\baselineskip}
\begin{tabular}{g|l}
    \hline
    Inputs: & Point, Vector\\
    \hline
    Fields: & Thickness, Color\\
    \hline
    Output: &  none\\
    \hline
\end{tabular}
\vspace{5pt}


This node is used to display a Vector, by representing it as an arrow.
Since a Vector is only a direction, the user must also provide the application point (i.e: the "tail") of the vector.
Just like with the Geometry Renderer, one can choose a color and the thickness of the arrow.

\section{Notes}
Assembling a graph does not have a 1:1 correspondency with writing procedural
code (e.g.: classic \CC{} code). You are only describing a series of
objects and a set of operations that manipulate those objects, not the order
in which the computations will be executed. The order of execution will be
decided by the software by looking at how nodes depend from each other.
It is an error to create a loop in the graph.

